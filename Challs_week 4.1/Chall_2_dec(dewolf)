extern void * std::cout = 0x0;
extern void * std::cin = 0x0;
extern unsigned char std::__ioinit = 0U;
extern void * __dso_handle = &__dso_handle;



long sub_1020() {/* jump -> undetermined */}



long sub_1036() {
    return sub_1020();
}



long sub_1046() {
    return sub_1020();
}



long sub_1056() {
    return sub_1020();
}



long sub_1066() {
    return sub_1020();
}



long sub_1076() {
    return sub_1020();
}



long sub_1086() {
    return sub_1020();
}



long sub_1096() {
    return sub_1020();
}



long sub_10a6() {
    return sub_1020();
}



long sub_10b6() {
    return sub_1020();
}



long sub_10c6() {
    return sub_1020();
}



long sub_10d6() {
    return sub_1020();
}



long sub_10e6() {
    return sub_1020();
}



long sub_10f6() {
    return sub_1020();
}



long sub_1106() {
    return sub_1020();
}



long sub_1116() {
    return sub_1020();
}



long sub_1126() {
    return sub_1020();
}



long sub_1136() {
    return sub_1020();
}



long sub_1146() {
    return sub_1020();
}



long sub_1156() {
    return sub_1020();
}



long sub_1166() {
    return sub_1020();
}



long sub_1176() {
    return sub_1020();
}

class std::string {
    std::string::_Alloc_hider _M_dataplus;
    unsigned long _M_string_length;
    union __anonymous_union {
        char [16] _M_local_buf;
        unsigned long _M_allocated_capacity;
    };
};
struct std::string::_Alloc_hider {
    char * _M_p;
};
union __anonymous_union {
    char [16] _M_local_buf;
    unsigned long _M_allocated_capacity;
};
class __normal_iterator<char*, std::string> {
    char * _M_current;
};

unsigned long checkPassword(std::string * arg1, long arg2) {
    void var_0;
    void var_4;
    void var_5;
    int i;
    int var_6;
    char var_8;
    char * var_9;
    std::allocator<char>::allocator(/* this */ &var_0);
    std::string::string(/* this */ &var_4, /* __s */ "dec");
    std::allocator<char>::~allocator(/* this */ &var_0);
    var_6 = std::string::length(/* this */ &var_4);
    if (std::string::length(/* this */ arg1) == 7) {
        std::string::string(/* this */ &var_5);
        for (i = 0; i < var_6; i++) {
            if (i == var_6 - 1) {
                std::string::operator+=(/* this */ &var_5);
                std::string::operator+=(/* this */ &var_5);
            }
            var_9 = std::string::at(/* this */ &var_4, /* __n */ i);
            std::string::operator+=(/* this */ &var_5, /* __c */ *var_9);
        }
        std::reverse<__normal_iterator<char*,_std::string>_>(std::string::begin(/* this */ arg1), std::string::end(/* this */ arg1));
        var_8 = data_0x15ee(arg1, &var_5);
        if (var_8 == 0) {
            var_6 = 1;
        }
        else {
            var_6 = 0;
            arg2 = 1L;
        }
        std::string::~string(/* this */ &var_5);
    }
    if ((std::string::length(/* this */ arg1) != 7) || (var_6 == 1)) {
        arg2 = 0L;
    }
    std::string::~string(/* this */ &var_4);
    return (unsigned int)(int)arg2;
}

struct _Unwind_Exception {
    unsigned long exception_class;
    void(_Unwind_Reason_Code, _Unwind_Exception *) * exception_cleanup;
    unsigned long private_1;
    unsigned long private_2;
};
enum _Unwind_Reason_Code {
    _URC_NO_REASON = 0,
    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
    _URC_FATAL_PHASE2_ERROR = 2,
    _URC_FATAL_PHASE1_ERROR = 3,
    _URC_NORMAL_STOP = 4,
    _URC_END_OF_STACK = 5,
    _URC_HANDLER_FOUND = 6,
    _URC_INSTALL_CONTEXT = 7,
    _URC_CONTINUE_UNWIND = 8
};
class std::allocator<char> {
    new_allocator<char> field_0;
};
class new_allocator<char> {
    ;
};

void sub_13df(_Unwind_Exception * arg1, void * arg2) {
    std::allocator<char>::~allocator(/* this */ arg2 - 29L);
    _Unwind_Resume(/* exc */ arg1);
}

class std::ostream {
    int() ** _vptr.basic_ostream;
};

int main(int argc, char ** argv, char ** envp) {
    char* var_10;
    void var_0;
    void var_6;
    long var_7;
    char var_8;
    std::ostream * var_9;
    std::string::string(/* this */ &var_0);
    var_9 = std::operator<<<std::char_traits<char>_>(/* __out */ std::cout, /* __s */ "Enter the password:");
    std::ostream::operator<<(/* this */ var_9, /* __pf */ _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_);
    std::getline<char>(/* __is */ std::cin, /* __str */ &var_0);
    std::string::string(/* this */ &var_6);
    var_8 = checkPassword(&var_6, var_7);
    if (var_8 == 0) {
        var_10 = "Login failed";
    }
    else {
        var_10 = "Login successful";
    }
    var_9 = std::operator<<<std::char_traits<char>_>(/* __out */ std::cout, /* __s */ var_10);
    std::ostream::operator<<(/* this */ var_9, /* __pf */ _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_);
    std::string::~string(/* this */ &var_6);
    std::string::~string(/* this */ &var_0);
    return 0;
}

struct _Unwind_Exception {
    unsigned long exception_class;
    void(_Unwind_Reason_Code, _Unwind_Exception *) * exception_cleanup;
    unsigned long private_1;
    unsigned long private_2;
};
enum _Unwind_Reason_Code {
    _URC_NO_REASON = 0,
    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
    _URC_FATAL_PHASE2_ERROR = 2,
    _URC_FATAL_PHASE1_ERROR = 3,
    _URC_NORMAL_STOP = 4,
    _URC_END_OF_STACK = 5,
    _URC_HANDLER_FOUND = 6,
    _URC_INSTALL_CONTEXT = 7,
    _URC_CONTINUE_UNWIND = 8
};
class std::string {
    std::string::_Alloc_hider _M_dataplus;
    unsigned long _M_string_length;
    union __anonymous_union {
        char [16] _M_local_buf;
        unsigned long _M_allocated_capacity;
    };
};
struct std::string::_Alloc_hider {
    char * _M_p;
};
union __anonymous_union {
    char [16] _M_local_buf;
    unsigned long _M_allocated_capacity;
};

void sub_14f0(_Unwind_Exception * arg1, void * arg2) {
    std::string::~string(/* this */ arg2 - 48L);
    std::string::~string(/* this */ arg2 - 80L);
    _Unwind_Resume(/* exc */ arg1);
}

struct _Unwind_Exception {
    unsigned long exception_class;
    void(_Unwind_Reason_Code, _Unwind_Exception *) * exception_cleanup;
    unsigned long private_1;
    unsigned long private_2;
};
enum _Unwind_Reason_Code {
    _URC_NO_REASON = 0,
    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
    _URC_FATAL_PHASE2_ERROR = 2,
    _URC_FATAL_PHASE1_ERROR = 3,
    _URC_NORMAL_STOP = 4,
    _URC_END_OF_STACK = 5,
    _URC_HANDLER_FOUND = 6,
    _URC_INSTALL_CONTEXT = 7,
    _URC_CONTINUE_UNWIND = 8
};
class std::string {
    std::string::_Alloc_hider _M_dataplus;
    unsigned long _M_string_length;
    union __anonymous_union {
        char [16] _M_local_buf;
        unsigned long _M_allocated_capacity;
    };
};
struct std::string::_Alloc_hider {
    char * _M_p;
};
union __anonymous_union {
    char [16] _M_local_buf;
    unsigned long _M_allocated_capacity;
};

void sub_1501(_Unwind_Exception * arg1, void * arg2) {
    std::string::~string(/* this */ arg2 - 80L);
    _Unwind_Resume(/* exc */ arg1);
}

class std::ios_base::Init {
    bool _S_synced_with_stdio;
};

void __static_initialization_and_destruction_0(int arg1, int arg2) {
    if ((arg1 == 1) && (arg2 == 0xffff)) {
        std::ios_base::Init::Init(/* this */ &std::__ioinit);
        __cxa_atexit(/* func */ _ZNSt8ios_base4InitD1Ev, &std::__ioinit, /* dso_handle */ __dso_handle);
    }
    return;
}



long (static_initializer)::checkPassword() {
    return __static_initialization_and_destruction_0(1, 0xffff);
}



long std::char_traits<char>::compare(long arg1, long arg2, unsigned long arg3) {
    if (arg3 == 0L) {
        arg1 = 0L;
    }
    else {
        arg1 = memcmp(arg1, arg2, arg3);
    }
    return arg1;
}



long std::reverse<__normal_iterator<char*,_std::string>_>(long arg1, long arg2) {
    std::__iterator_category<__normal_iterator<char*,_std::string>_>();
    return std::__reverse<__normal_iterator<char*,_std::string>_>(arg1, arg2);
}

class std::string {
    std::string::_Alloc_hider _M_dataplus;
    unsigned long _M_string_length;
    union __anonymous_union {
        char [16] _M_local_buf;
        unsigned long _M_allocated_capacity;
    };
};
struct std::string::_Alloc_hider {
    char * _M_p;
};
union __anonymous_union {
    char [16] _M_local_buf;
    unsigned long _M_allocated_capacity;
};

long data_0x15ee(std::string * arg1, std::string * arg2) {
    long var_0;
    if ((std::string::size(/* this */ arg1) == std::string::size(/* this */ arg2)) && (std::char_traits<char>::compare(std::string::data(/* this */ arg1), std::string::data(/* this */ arg2), std::string::size(/* this */ arg1)) == 0)) {
        var_0 = 1L;
    }
    else {
        var_0 = 0L;
    }
    return var_0;
}



long std::__iterator_category<__normal_iterator<char*,_std::string>_>() {
    return;
}



long std::__reverse<__normal_iterator<char*,_std::string>_>(long arg1, long arg2) {
    long var_1;
    char var_0;
    long * var_2;
    var_2 = arg2;
    var_1 = arg1;
    var_0 = operator==<char*,_std::string>(&var_1, &var_2);
    if (var_0 == 0) {
        __normal_iterator<char*,_std::string>::operator--(&var_2);
        while (true) {
            var_0 = data_0x1752(&var_1, &var_2);
            if (var_0 == 0) {
                break;
            }
            data_0x178e(var_1, var_2);
            __normal_iterator<char*,_std::string>::operator++(&var_1);
            __normal_iterator<char*,_std::string>::operator--(&var_2);
        }
    }
    return var_0;
}



long operator==<char*,_std::string>(long arg1, long arg2) {
    long * var_0;
    long * var_1;
    var_0 = __normal_iterator<char*,_std::string>::base(arg1);
    var_1 = __normal_iterator<char*,_std::string>::base(arg2);
    return *var_0 == *var_1;
}



long * __normal_iterator<char*,_std::string>::operator--(long * arg1) {
    *arg1--;
    return arg1;
}



long data_0x1752(long arg1, long arg2) {
    long * var_0;
    long * var_1;
    var_0 = __normal_iterator<char*,_std::string>::base(arg1);
    var_1 = __normal_iterator<char*,_std::string>::base(arg2);
    return *var_0 < *var_1;
}



char * data_0x178e(long arg1, long arg2) {
    long var_2;
    long var_3;
    char * var_0;
    char * var_1;
    var_2 = arg1;
    var_3 = arg2;
    var_1 = __normal_iterator<char*,_std::string>::operator*(&var_3);
    var_0 = __normal_iterator<char*,_std::string>::operator*(&var_2);
    return data_0x181b(var_0, var_1);
}



long * __normal_iterator<char*,_std::string>::operator++(long * arg1) {
    *arg1++;
    return arg1;
}



long __normal_iterator<char*,_std::string>::base(long arg1) {
    return arg1;
}



long __normal_iterator<char*,_std::string>::operator*(long * arg1) {
    return *arg1;
}



long std::move<char&>(long arg1) {
    return arg1;
}



char * data_0x181b(char * arg1, char * arg2) {
    char * var_0;
    char * var_1;
    char * var_2;
    var_0 = std::move<char&>(arg1);
    var_1 = std::move<char&>(arg2);
    *arg1 = *var_1;
    var_2 = *var_0;
    arg1 = std::move<char&>(&var_2);
    *arg2 = *arg1;
    return arg2;
}
